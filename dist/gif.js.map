{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///gif.js","webpack:///webpack/bootstrap 818611bfc8d8a92193a1","webpack:///./src/gif.coffee","webpack:///./~/events/events.js","webpack:///./src/browser.coffee"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","EventEmitter","GIF","browser","extend","child","parent","ctor","constructor","key","hasProp","prototype","__super__","hasOwnProperty","indexOf","item","i","l","length","superClass","options","base","taskQueue","value","running","frames","previousFrames","Map","pendingFrameCount","groups","freeWorkers","activeWorkers","setOptions","defaults","batchSizeForRendering","workers","curBatchSizeLastIndex","spawnWorkers","frameDefaults","workerScript","repeat","background","quality","width","height","transparent","debug","delay","copy","applyCropOptimization","transparencyDifferenceThreshold","applyTransparencyOptimization","dispose","setOption","_canvas","results","push","getFrameData","image","frame","ImageData","data","CanvasRenderingContext2D","WebGLRenderingContext","getContextData","context","childNodes","Error","getImageData","addFrame","index","previousFrame","previousImage","has","get","set","flushTasks","then","addBatchForRendering","emit","render","j","k","numWorkers","ref","ref1","nextFrame","finishedFrames","Math","min","imageParts","globalPalette","renderNextFrame","abort","worker","shift","log","terminate","task","Promise","resolve","setTimeout","all","error","apply","forEach","_this","Worker","onmessage","event","splice","frameFinished","duplicate","indexOfDuplicate","indexOfFirstInGroup","flush","finishRendering","len","len1","len2","len3","len4","offset","page","ref2","ref3","pageSize","cursor","round","Uint8Array","Blob","type","getTask","postMessage","ctx","document","createElement","getContext","setFill","fillRect","drawImage","getFrameDataForTask","last","dither","canTransfer","previousFrameData","msg","console","_events","_maxListeners","undefined","isFunction","arg","isNumber","isObject","isUndefined","defaultMaxListeners","setMaxListeners","n","isNaN","TypeError","er","handler","args","listeners","arguments","err","Array","slice","addListener","listener","newListener","warned","trace","on","once","g","removeListener","fired","list","position","removeAllListeners","ret","listenerCount","evlistener","emitter","UA","mode","platform","ua","navigator","userAgent","toLowerCase","match","documentMode","name","version","parseFloat","parseInt"],"mappings":"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","file":"gif.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"GIF\"] = factory();\n\telse\n\t\troot[\"GIF\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"GIF\"] = factory();\n\telse\n\t\troot[\"GIF\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar EventEmitter, GIF, browser,\n\t  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t  hasProp = {}.hasOwnProperty,\n\t  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\t\n\tEventEmitter = __webpack_require__(1).EventEmitter;\n\t\n\tbrowser = __webpack_require__(2);\n\t\n\tGIF = (function(superClass) {\n\t  var defaults, frameDefaults;\n\t\n\t  extend(GIF, superClass);\n\t\n\t  defaults = {\n\t    workerScript: 'gif.worker.js',\n\t    workers: 2,\n\t    repeat: 0,\n\t    background: '#fff',\n\t    quality: 10,\n\t    width: null,\n\t    height: null,\n\t    transparent: null,\n\t    debug: false\n\t  };\n\t\n\t  frameDefaults = {\n\t    delay: 500,\n\t    copy: false,\n\t    applyCropOptimization: false,\n\t    transparencyDifferenceThreshold: 1,\n\t    applyTransparencyOptimization: false,\n\t    dispose: -1\n\t  };\n\t\n\t  function GIF(options) {\n\t    var base, key, taskQueue, value;\n\t    this.running = false;\n\t    this.options = {};\n\t    this.frames = [];\n\t    this.previousFrames = new Map();\n\t    this.pendingFrameCount = 0;\n\t    this.groups = new Map();\n\t    this.freeWorkers = [];\n\t    this.activeWorkers = [];\n\t    this.setOptions(options);\n\t    for (key in defaults) {\n\t      value = defaults[key];\n\t      if ((base = this.options)[key] == null) {\n\t        base[key] = value;\n\t      }\n\t    }\n\t    this.batchSizeForRendering = this.options.workers;\n\t    this.curBatchSizeLastIndex = 0;\n\t    this.spawnWorkers();\n\t    taskQueue = [];\n\t  }\n\t\n\t  GIF.prototype.setOption = function(key, value) {\n\t    this.options[key] = value;\n\t    if ((this._canvas != null) && (key === 'width' || key === 'height')) {\n\t      return this._canvas[key] = value;\n\t    }\n\t  };\n\t\n\t  GIF.prototype.setOptions = function(options) {\n\t    var key, results, value;\n\t    results = [];\n\t    for (key in options) {\n\t      if (!hasProp.call(options, key)) continue;\n\t      value = options[key];\n\t      results.push(this.setOption(key, value));\n\t    }\n\t    return results;\n\t  };\n\t\n\t  GIF.prototype.getFrameData = function(image, frame, options) {\n\t    if (options == null) {\n\t      options = {};\n\t    }\n\t    if ((typeof ImageData !== \"undefined\" && ImageData !== null) && image instanceof ImageData) {\n\t      frame.data = image.data;\n\t    } else if (((typeof CanvasRenderingContext2D !== \"undefined\" && CanvasRenderingContext2D !== null) && image instanceof CanvasRenderingContext2D) || ((typeof WebGLRenderingContext !== \"undefined\" && WebGLRenderingContext !== null) && image instanceof WebGLRenderingContext)) {\n\t      if (options.copy) {\n\t        frame.data = this.getContextData(image);\n\t      } else {\n\t        frame.context = image;\n\t      }\n\t    } else if (image.childNodes != null) {\n\t      if (options.copy) {\n\t        frame.data = this.getImageData(image);\n\t      } else {\n\t        frame.image = image;\n\t      }\n\t    } else {\n\t      throw new Error('Invalid image');\n\t    }\n\t    return frame;\n\t  };\n\t\n\t  GIF.prototype.addFrame = function(image, options) {\n\t    var frame, index, key, previousFrame;\n\t    if (options == null) {\n\t      options = {};\n\t    }\n\t    frame = {};\n\t    previousFrame = {};\n\t    frame.transparent = this.options.transparent;\n\t    for (key in frameDefaults) {\n\t      frame[key] = options[key] || frameDefaults[key];\n\t    }\n\t    if (this.options.width == null) {\n\t      this.setOption('width', image.width);\n\t    }\n\t    if (this.options.height == null) {\n\t      this.setOption('height', image.height);\n\t    }\n\t    frame = this.getFrameData(image, frame, options);\n\t    if (this.options.applyTransparencyOptimization && (options.previousImage != null)) {\n\t      previousFrame = this.getFrameData(options.previousImage, previousFrame, options);\n\t    }\n\t    index = this.frames.length;\n\t    if (index > 0 && frame.data) {\n\t      if (this.groups.has(frame.data)) {\n\t        this.groups.get(frame.data).push(index);\n\t      } else {\n\t        this.groups.set(frame.data, [index]);\n\t      }\n\t    }\n\t    this.frames.push(frame);\n\t    if (previousFrame.data != null) {\n\t      this.previousFrames.set(index, previousFrame);\n\t    }\n\t    if (this.pendingFrameCount > this.batchSizeForRendering) {\n\t      if (this.freeWorkers.length === 0 || this.taskQueue.length > 0) {\n\t        flushTasks().then(function() {\n\t          return this.addBatchForRendering();\n\t        });\n\t      } else {\n\t        this.addBatchForRendering();\n\t      }\n\t    }\n\t    return this.emit('progress', 1);\n\t  };\n\t\n\t  GIF.prototype.render = function() {\n\t    var i, j, k, numWorkers, ref, ref1;\n\t    if (this.running) {\n\t      throw new Error('Already running');\n\t    }\n\t    if ((this.options.width == null) || (this.options.height == null)) {\n\t      throw new Error('Width and height must be set prior to rendering');\n\t    }\n\t    this.running = true;\n\t    this.nextFrame = 0;\n\t    this.finishedFrames = 0;\n\t    for (i = j = 0, ref = Math.min(this.pendingFrameCount, this.batchSizeForRendering); 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n\t      this.imageParts.push(null);\n\t    }\n\t    numWorkers = this.freeWorkers.length;\n\t    if (this.options.globalPalette === true) {\n\t      this.renderNextFrame();\n\t    } else {\n\t      for (i = k = 0, ref1 = numWorkers; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {\n\t        this.renderNextFrame();\n\t      }\n\t    }\n\t    this.emit('start');\n\t    return this.emit('progress', 0);\n\t  };\n\t\n\t  GIF.prototype.abort = function() {\n\t    var worker;\n\t    while (true) {\n\t      worker = this.activeWorkers.shift();\n\t      if (worker == null) {\n\t        break;\n\t      }\n\t      this.log(\"killing active worker\");\n\t      worker.terminate();\n\t    }\n\t    this.running = false;\n\t    return this.emit('abort');\n\t  };\n\t\n\t  GIF.prototype.addBatchForRendering = function() {\n\t    var task;\n\t    this.curBatchSizeLastIndex = this.curBatchSizeLastIndex + this.batchSizeForRendering;\n\t    task = new Promise(function(resolve) {\n\t      return setTimeout(function() {\n\t        this.render();\n\t        this.taskQueue = [];\n\t        return this.resolve();\n\t      });\n\t    });\n\t    return this.taskQueue.push(task);\n\t  };\n\t\n\t  GIF.prototype.flushTasks = function() {\n\t    return Promise.all(this.taskQueue).then(function() {\n\t      return this.taskQueue = [];\n\t    })[\"catch\"](function(error) {\n\t      throw error;\n\t    });\n\t  };\n\t\n\t  GIF.prototype.spawnWorkers = function() {\n\t    var j, numWorkers, ref, results;\n\t    numWorkers = Math.min(this.options.workers, this.frames.length);\n\t    (function() {\n\t      results = [];\n\t      for (var j = ref = this.freeWorkers.length; ref <= numWorkers ? j < numWorkers : j > numWorkers; ref <= numWorkers ? j++ : j--){ results.push(j); }\n\t      return results;\n\t    }).apply(this).forEach((function(_this) {\n\t      return function(i) {\n\t        var worker;\n\t        _this.log(\"spawning worker \" + i);\n\t        worker = new Worker(_this.options.workerScript);\n\t        worker.onmessage = function(event) {\n\t          _this.activeWorkers.splice(_this.activeWorkers.indexOf(worker), 1);\n\t          _this.freeWorkers.push(worker);\n\t          return _this.frameFinished(event.data, false);\n\t        };\n\t        return _this.freeWorkers.push(worker);\n\t      };\n\t    })(this));\n\t    return numWorkers;\n\t  };\n\t\n\t  GIF.prototype.frameFinished = function(frame, duplicate) {\n\t    var i, indexOfDuplicate, indexOfFirstInGroup, j, ref;\n\t    this.finishedFrames++;\n\t    this.pendingFrameCount--;\n\t    if (!duplicate) {\n\t      this.log(\"frame \" + (frame.index + 1) + \" finished - \" + this.activeWorkers.length + \" active\");\n\t      this.emit('progress', 1);\n\t      this.imageParts[frame.index] = frame;\n\t    } else {\n\t      indexOfDuplicate = this.frames.indexOf(frame);\n\t      indexOfFirstInGroup = this.groups.get(frame.data)[0];\n\t      this.log(\"frame \" + (indexOfDuplicate + 1) + \" is duplicate of \" + indexOfFirstInGroup + \" - \" + this.activeWorkers.length + \" active\");\n\t      this.imageParts[indexOfDuplicate] = {\n\t        indexOfFirstInGroup: indexOfFirstInGroup\n\t      };\n\t    }\n\t    if (this.options.globalPalette === true && !duplicate) {\n\t      this.options.globalPalette = frame.globalPalette;\n\t      this.log(\"global palette analyzed\");\n\t      if (this.frames.length > 2) {\n\t        for (i = j = 1, ref = this.freeWorkers.length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {\n\t          this.renderNextFrame();\n\t        }\n\t      }\n\t    }\n\t    if (indexOf.call(this.imageParts, null) >= 0) {\n\t      return this.renderNextFrame();\n\t    }\n\t  };\n\t\n\t  GIF.prototype.flush = function() {\n\t    return this.flushTasks.then(function() {\n\t      this.render();\n\t      return this.finishRendering();\n\t    });\n\t  };\n\t\n\t  GIF.prototype.finishRendering = function() {\n\t    var data, frame, i, image, index, j, k, l, len, len1, len2, len3, len4, m, offset, page, ref, ref1, ref2, ref3;\n\t    ref = this.imageParts;\n\t    for (index = j = 0, len1 = ref.length; j < len1; index = ++j) {\n\t      frame = ref[index];\n\t      if (frame.indexOfFirstInGroup) {\n\t        this.imageParts[index] = this.imageParts[frame.indexOfFirstInGroup];\n\t      }\n\t    }\n\t    len = 0;\n\t    ref1 = this.imageParts;\n\t    for (k = 0, len2 = ref1.length; k < len2; k++) {\n\t      frame = ref1[k];\n\t      len += (frame.data.length - 1) * frame.pageSize + frame.cursor;\n\t    }\n\t    len += frame.pageSize - frame.cursor;\n\t    this.log(\"rendering finished - filesize \" + (Math.round(len / 1000)) + \"kb\");\n\t    data = new Uint8Array(len);\n\t    offset = 0;\n\t    ref2 = this.imageParts;\n\t    for (l = 0, len3 = ref2.length; l < len3; l++) {\n\t      frame = ref2[l];\n\t      ref3 = frame.data;\n\t      for (i = m = 0, len4 = ref3.length; m < len4; i = ++m) {\n\t        page = ref3[i];\n\t        data.set(page, offset);\n\t        if (i === frame.data.length - 1) {\n\t          offset += frame.cursor;\n\t        } else {\n\t          offset += frame.pageSize;\n\t        }\n\t      }\n\t    }\n\t    image = new Blob([data], {\n\t      type: 'image/gif'\n\t    });\n\t    return this.emit('finished', image, data);\n\t  };\n\t\n\t  GIF.prototype.renderNextFrame = function() {\n\t    var frame, index, previousFrame, task, worker;\n\t    if (this.freeWorkers.length === 0) {\n\t      throw new Error('No free workers');\n\t    }\n\t    if (this.nextFrame >= this.frames.length || this.nextFrame >= this.imageParts.length) {\n\t      return;\n\t    }\n\t    index = this.nextFrame++;\n\t    frame = this.frames[index];\n\t    previousFrame = null;\n\t    if (this.previousFrames.has(index - 1)) {\n\t      previousFrame = this.previousFrames.get(index - 1);\n\t    }\n\t    if (index > 0 && this.groups.has(frame.data) && this.groups.get(frame.data)[0] !== index) {\n\t      setTimeout((function(_this) {\n\t        return function() {\n\t          return _this.frameFinished(frame, true);\n\t        };\n\t      })(this), 0);\n\t      return;\n\t    }\n\t    worker = this.freeWorkers.shift();\n\t    task = this.getTask(frame, previousFrame);\n\t    this.log(\"starting frame \" + (task.index + 1) + \" of \" + this.frames.length);\n\t    this.activeWorkers.push(worker);\n\t    worker.postMessage(task);\n\t    this.frames[index] = null;\n\t    return this.previousFrames[index - 1] = null;\n\t  };\n\t\n\t  GIF.prototype.getContextData = function(ctx) {\n\t    return ctx.getImageData(0, 0, this.options.width, this.options.height).data;\n\t  };\n\t\n\t  GIF.prototype.getImageData = function(image) {\n\t    var ctx;\n\t    if (this._canvas == null) {\n\t      this._canvas = document.createElement('canvas');\n\t      this._canvas.width = this.options.width;\n\t      this._canvas.height = this.options.height;\n\t    }\n\t    ctx = this._canvas.getContext('2d');\n\t    ctx.setFill = this.options.background;\n\t    ctx.fillRect(0, 0, this.options.width, this.options.height);\n\t    ctx.drawImage(image, 0, 0);\n\t    return this.getContextData(ctx);\n\t  };\n\t\n\t  GIF.prototype.getFrameDataForTask = function(frame) {\n\t    if (frame.data != null) {\n\t      return frame.data;\n\t    } else if (frame.context != null) {\n\t      return this.getContextData(frame.context);\n\t    } else if (frame.image != null) {\n\t      return this.getImageData(frame.image);\n\t    } else {\n\t      throw new Error('Invalid frame');\n\t    }\n\t  };\n\t\n\t  GIF.prototype.getTask = function(frame, previousFrame) {\n\t    var index, task;\n\t    index = this.frames.indexOf(frame);\n\t    task = {\n\t      index: index,\n\t      last: index === (this.frames.length - 1),\n\t      delay: frame.delay,\n\t      transparent: frame.transparent,\n\t      width: this.options.width,\n\t      height: this.options.height,\n\t      quality: this.options.quality,\n\t      dither: this.options.dither,\n\t      globalPalette: this.options.globalPalette,\n\t      repeat: this.options.repeat,\n\t      canTransfer: true,\n\t      data: this.getFrameDataForTask(frame),\n\t      applyCropOptimization: this.options.applyCropOptimization,\n\t      transparencyDifferenceThreshold: this.options.transparencyDifferenceThreshold,\n\t      dispose: this.options.dispose,\n\t      applyTransparencyOptimization: this.options.applyTransparencyOptimization\n\t    };\n\t    if (previousFrame != null) {\n\t      task.previousFrameData = this.getFrameDataForTask(previousFrame);\n\t    }\n\t    return task;\n\t  };\n\t\n\t  GIF.prototype.log = function(msg) {\n\t    if (this.options.debug) {\n\t      return console.log(msg);\n\t    }\n\t  };\n\t\n\t  return GIF;\n\t\n\t})(EventEmitter);\n\t\n\tmodule.exports = GIF;\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\tfunction EventEmitter() {\n\t  this._events = this._events || {};\n\t  this._maxListeners = this._maxListeners || undefined;\n\t}\n\tmodule.exports = EventEmitter;\n\t\n\t// Backwards-compat with node 0.10.x\n\tEventEmitter.EventEmitter = EventEmitter;\n\t\n\tEventEmitter.prototype._events = undefined;\n\tEventEmitter.prototype._maxListeners = undefined;\n\t\n\t// By default EventEmitters will print a warning if more than 10 listeners are\n\t// added to it. This is a useful default which helps finding memory leaks.\n\tEventEmitter.defaultMaxListeners = 10;\n\t\n\t// Obviously not all Emitters should be limited to 10. This function allows\n\t// that to be increased. Set to zero for unlimited.\n\tEventEmitter.prototype.setMaxListeners = function(n) {\n\t  if (!isNumber(n) || n < 0 || isNaN(n))\n\t    throw TypeError('n must be a positive number');\n\t  this._maxListeners = n;\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.emit = function(type) {\n\t  var er, handler, len, args, i, listeners;\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // If there is no 'error' event listener then throw.\n\t  if (type === 'error') {\n\t    if (!this._events.error ||\n\t        (isObject(this._events.error) && !this._events.error.length)) {\n\t      er = arguments[1];\n\t      if (er instanceof Error) {\n\t        throw er; // Unhandled 'error' event\n\t      } else {\n\t        // At least give some kind of context to the user\n\t        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n\t        err.context = er;\n\t        throw err;\n\t      }\n\t    }\n\t  }\n\t\n\t  handler = this._events[type];\n\t\n\t  if (isUndefined(handler))\n\t    return false;\n\t\n\t  if (isFunction(handler)) {\n\t    switch (arguments.length) {\n\t      // fast cases\n\t      case 1:\n\t        handler.call(this);\n\t        break;\n\t      case 2:\n\t        handler.call(this, arguments[1]);\n\t        break;\n\t      case 3:\n\t        handler.call(this, arguments[1], arguments[2]);\n\t        break;\n\t      // slower\n\t      default:\n\t        args = Array.prototype.slice.call(arguments, 1);\n\t        handler.apply(this, args);\n\t    }\n\t  } else if (isObject(handler)) {\n\t    args = Array.prototype.slice.call(arguments, 1);\n\t    listeners = handler.slice();\n\t    len = listeners.length;\n\t    for (i = 0; i < len; i++)\n\t      listeners[i].apply(this, args);\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\tEventEmitter.prototype.addListener = function(type, listener) {\n\t  var m;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // To avoid recursion in the case that type === \"newListener\"! Before\n\t  // adding it to the listeners, first emit \"newListener\".\n\t  if (this._events.newListener)\n\t    this.emit('newListener', type,\n\t              isFunction(listener.listener) ?\n\t              listener.listener : listener);\n\t\n\t  if (!this._events[type])\n\t    // Optimize the case of one listener. Don't need the extra array object.\n\t    this._events[type] = listener;\n\t  else if (isObject(this._events[type]))\n\t    // If we've already got an array, just append.\n\t    this._events[type].push(listener);\n\t  else\n\t    // Adding the second element, need to change to array.\n\t    this._events[type] = [this._events[type], listener];\n\t\n\t  // Check for listener leak\n\t  if (isObject(this._events[type]) && !this._events[type].warned) {\n\t    if (!isUndefined(this._maxListeners)) {\n\t      m = this._maxListeners;\n\t    } else {\n\t      m = EventEmitter.defaultMaxListeners;\n\t    }\n\t\n\t    if (m && m > 0 && this._events[type].length > m) {\n\t      this._events[type].warned = true;\n\t      console.error('(node) warning: possible EventEmitter memory ' +\n\t                    'leak detected. %d listeners added. ' +\n\t                    'Use emitter.setMaxListeners() to increase limit.',\n\t                    this._events[type].length);\n\t      if (typeof console.trace === 'function') {\n\t        // not supported in IE 10\n\t        console.trace();\n\t      }\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\t\n\tEventEmitter.prototype.once = function(type, listener) {\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  var fired = false;\n\t\n\t  function g() {\n\t    this.removeListener(type, g);\n\t\n\t    if (!fired) {\n\t      fired = true;\n\t      listener.apply(this, arguments);\n\t    }\n\t  }\n\t\n\t  g.listener = listener;\n\t  this.on(type, g);\n\t\n\t  return this;\n\t};\n\t\n\t// emits a 'removeListener' event iff the listener was removed\n\tEventEmitter.prototype.removeListener = function(type, listener) {\n\t  var list, position, length, i;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events || !this._events[type])\n\t    return this;\n\t\n\t  list = this._events[type];\n\t  length = list.length;\n\t  position = -1;\n\t\n\t  if (list === listener ||\n\t      (isFunction(list.listener) && list.listener === listener)) {\n\t    delete this._events[type];\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t\n\t  } else if (isObject(list)) {\n\t    for (i = length; i-- > 0;) {\n\t      if (list[i] === listener ||\n\t          (list[i].listener && list[i].listener === listener)) {\n\t        position = i;\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (position < 0)\n\t      return this;\n\t\n\t    if (list.length === 1) {\n\t      list.length = 0;\n\t      delete this._events[type];\n\t    } else {\n\t      list.splice(position, 1);\n\t    }\n\t\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.removeAllListeners = function(type) {\n\t  var key, listeners;\n\t\n\t  if (!this._events)\n\t    return this;\n\t\n\t  // not listening for removeListener, no need to emit\n\t  if (!this._events.removeListener) {\n\t    if (arguments.length === 0)\n\t      this._events = {};\n\t    else if (this._events[type])\n\t      delete this._events[type];\n\t    return this;\n\t  }\n\t\n\t  // emit removeListener for all listeners on all events\n\t  if (arguments.length === 0) {\n\t    for (key in this._events) {\n\t      if (key === 'removeListener') continue;\n\t      this.removeAllListeners(key);\n\t    }\n\t    this.removeAllListeners('removeListener');\n\t    this._events = {};\n\t    return this;\n\t  }\n\t\n\t  listeners = this._events[type];\n\t\n\t  if (isFunction(listeners)) {\n\t    this.removeListener(type, listeners);\n\t  } else if (listeners) {\n\t    // LIFO order\n\t    while (listeners.length)\n\t      this.removeListener(type, listeners[listeners.length - 1]);\n\t  }\n\t  delete this._events[type];\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.listeners = function(type) {\n\t  var ret;\n\t  if (!this._events || !this._events[type])\n\t    ret = [];\n\t  else if (isFunction(this._events[type]))\n\t    ret = [this._events[type]];\n\t  else\n\t    ret = this._events[type].slice();\n\t  return ret;\n\t};\n\t\n\tEventEmitter.prototype.listenerCount = function(type) {\n\t  if (this._events) {\n\t    var evlistener = this._events[type];\n\t\n\t    if (isFunction(evlistener))\n\t      return 1;\n\t    else if (evlistener)\n\t      return evlistener.length;\n\t  }\n\t  return 0;\n\t};\n\t\n\tEventEmitter.listenerCount = function(emitter, type) {\n\t  return emitter.listenerCount(type);\n\t};\n\t\n\tfunction isFunction(arg) {\n\t  return typeof arg === 'function';\n\t}\n\t\n\tfunction isNumber(arg) {\n\t  return typeof arg === 'number';\n\t}\n\t\n\tfunction isObject(arg) {\n\t  return typeof arg === 'object' && arg !== null;\n\t}\n\t\n\tfunction isUndefined(arg) {\n\t  return arg === void 0;\n\t}\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n\t\n\t/* CoffeeScript version of the browser detection from MooTools */\n\tvar UA, browser, mode, platform, ua;\n\t\n\tua = navigator.userAgent.toLowerCase();\n\t\n\tplatform = navigator.platform.toLowerCase();\n\t\n\tUA = ua.match(/(opera|ie|firefox|chrome|version)[\\s\\/:]([\\w\\d\\.]+)?.*?(safari|version[\\s\\/:]([\\w\\d\\.]+)|$)/) || [null, 'unknown', 0];\n\t\n\tmode = UA[1] === 'ie' && document.documentMode;\n\t\n\tbrowser = {\n\t  name: UA[1] === 'version' ? UA[3] : UA[1],\n\t  version: mode || parseFloat(UA[1] === 'opera' && UA[4] ? UA[4] : UA[2]),\n\t  platform: {\n\t    name: ua.match(/ip(?:ad|od|hone)/) ? 'ios' : (ua.match(/(?:webos|android)/) || platform.match(/mac|win|linux/) || ['other'])[0]\n\t  }\n\t};\n\t\n\tbrowser[browser.name] = true;\n\t\n\tbrowser[browser.name + parseInt(browser.version, 10)] = true;\n\t\n\tbrowser.platform[browser.platform.name] = true;\n\t\n\tmodule.exports = browser;\n\n\n/***/ })\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// gif.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 818611bfc8d8a92193a1","{EventEmitter} = require 'events'\nbrowser = require './browser.coffee'\n\nclass GIF extends EventEmitter\n\n  defaults =\n    workerScript: 'gif.worker.js'\n    workers: 2\n    repeat: 0 # repeat forever, -1 = repeat once\n    background: '#fff'\n    quality: 10 # pixel sample interval, lower is better\n    width: null # size derermined from first frame if possible\n    height: null\n    transparent: null\n    debug: false\n\n  frameDefaults =\n    delay: 500 # ms\n    copy: false\n    applyCropOptimization: false\n    transparencyDifferenceThreshold: 1\n    applyTransparencyOptimization: false\n    dispose: -1\n\n  constructor: (options) ->\n    @running = false\n\n    @options = {}\n    @frames = []\n    @previousFrames = new Map()\n    @pendingFrameCount = 0\n\n    # TODO: compare by instance and not by data\n    @groups = new Map() # for [data1, data1, data2, data1] @groups[data1] == [1, 3] and @groups[data2] = [2]\n\n    @freeWorkers = []\n    @activeWorkers = []\n\n    @setOptions options\n    for key, value of defaults\n      @options[key] ?= value\n\n    @batchSizeForRendering = @options.workers\n    @curBatchSizeLastIndex = 0\n\n    # Spawn workers once and re-use them for all batches.\n    @spawnWorkers()\n    taskQueue = []\n\n  setOption: (key, value) ->\n    @options[key] = value\n    if @_canvas? and key in ['width', 'height']\n      @_canvas[key] = value\n\n  setOptions: (options) ->\n    @setOption key, value for own key, value of options\n\n  getFrameData: (image, frame, options={}) ->\n    if ImageData? and image instanceof ImageData\n       frame.data = image.data\n    else if (CanvasRenderingContext2D? and image instanceof CanvasRenderingContext2D) or (WebGLRenderingContext? and image instanceof WebGLRenderingContext)\n      if options.copy\n        frame.data = @getContextData image\n      else\n        frame.context = image\n    else if image.childNodes?\n      if options.copy\n        frame.data = @getImageData image\n      else\n        frame.image = image\n    else\n      throw new Error 'Invalid image'\n    return frame\n\n  addFrame: (image, options={}) ->\n    frame = {}\n    previousFrame = {}\n    frame.transparent = @options.transparent\n    for key of frameDefaults\n      frame[key] = options[key] or frameDefaults[key]\n\n    # use the images width and height for options unless already set\n    @setOption 'width', image.width unless @options.width?\n    @setOption 'height', image.height unless @options.height?\n\n    frame = @getFrameData image, frame, options\n    if @options.applyTransparencyOptimization and options.previousImage?\n      previousFrame = @getFrameData options.previousImage, previousFrame, options\n\n    # find duplicates in frames.data\n    index = @frames.length\n    if index > 0 and frame.data # frame 0 contains header, do not count it\n      if @groups.has(frame.data)\n        @groups.get(frame.data).push index\n      else\n        @groups.set frame.data, [index]\n\n    @frames.push frame\n    if previousFrame.data?\n      @previousFrames.set index, previousFrame\n\n    if @pendingFrameCount > @batchSizeForRendering\n      # If all workers are occupied, then flush tasks to free workers.\n      if @freeWorkers.length == 0 || @taskQueue.length > 0\n        flushTasks().then ->\n          @addBatchForRendering()\n      else\n        @addBatchForRendering()\n    @emit 'progress', 1\n\n  render: ->\n    throw new Error 'Already running' if @running\n\n    if not @options.width? or not @options.height?\n      throw new Error 'Width and height must be set prior to rendering'\n\n    @running = true\n    @nextFrame = 0\n    @finishedFrames = 0\n\n    for i in [0...Math.min @pendingFrameCount, @batchSizeForRendering]\n      @imageParts.push(null)\n\n    numWorkers = @freeWorkers.length\n    # we need to wait for the palette\n    if @options.globalPalette == true\n      @renderNextFrame()\n    else\n      @renderNextFrame() for i in [0...numWorkers]\n\n    @emit 'start'\n    @emit 'progress', 0\n\n  abort: ->\n    loop\n      worker = @activeWorkers.shift()\n      break unless worker?\n      @log \"killing active worker\"\n      worker.terminate()\n    @running = false\n    @emit 'abort'\n\n  # private\n\n  addBatchForRendering: ->\n    @curBatchSizeLastIndex = @curBatchSizeLastIndex + @batchSizeForRendering\n    task = new Promise (resolve) ->\n      setTimeout ->\n        @render()\n        @taskQueue = []\n        @resolve()\n    @taskQueue.push(task)\n\n  flushTasks: ->\n    Promise.all(@taskQueue)\n      .then () ->\n        @taskQueue = []\n      .catch (error) ->\n        throw error\n\n  spawnWorkers: ->\n    numWorkers = Math.min(@options.workers, @frames.length)\n    [@freeWorkers.length...numWorkers].forEach (i) =>\n      @log \"spawning worker #{ i }\"\n      worker = new Worker @options.workerScript\n      worker.onmessage = (event) =>\n        @activeWorkers.splice @activeWorkers.indexOf(worker), 1\n        @freeWorkers.push worker\n        @frameFinished event.data, false\n      @freeWorkers.push worker\n    return numWorkers\n\n  frameFinished: (frame, duplicate) ->\n    @finishedFrames++\n    @pendingFrameCount--\n    if not duplicate\n      @log \"frame #{ frame.index + 1 } finished - #{ @activeWorkers.length } active\"\n      @emit 'progress', 1\n      @imageParts[frame.index] = frame\n    else\n      indexOfDuplicate = @frames.indexOf frame\n      indexOfFirstInGroup = @groups.get(frame.data)[0]\n      @log \"frame #{ indexOfDuplicate + 1 } is duplicate of #{ indexOfFirstInGroup } - #{ @activeWorkers.length } active\"\n      @imageParts[indexOfDuplicate] = { indexOfFirstInGroup: indexOfFirstInGroup } # do not put frame here, as it may not be available still. Put index.\n    # remember calculated palette, spawn the rest of the workers\n    if @options.globalPalette == true and not duplicate\n      @options.globalPalette = frame.globalPalette\n      @log \"global palette analyzed\"\n      @renderNextFrame() for i in [1...@freeWorkers.length] if @frames.length > 2\n    if null in @imageParts\n      @renderNextFrame()\n\n  flush: ->\n    @flushTasks.then ->\n      @render()\n      @finishRendering()\n\n  finishRendering: ->\n    for frame, index in @imageParts\n      @imageParts[index] = @imageParts[frame.indexOfFirstInGroup] if frame.indexOfFirstInGroup\n    len = 0\n    for frame in @imageParts\n      len += (frame.data.length - 1) * frame.pageSize + frame.cursor\n    len += frame.pageSize - frame.cursor\n    @log \"rendering finished - filesize #{ Math.round(len / 1000) }kb\"\n    data = new Uint8Array len\n    offset = 0\n    for frame in @imageParts\n      for page, i in frame.data\n        data.set page, offset\n        if i is frame.data.length - 1\n          offset += frame.cursor\n        else\n          offset += frame.pageSize\n\n    image = new Blob [data],\n      type: 'image/gif'\n\n    @emit 'finished', image, data\n\n  renderNextFrame: ->\n    throw new Error 'No free workers' if @freeWorkers.length is 0\n    return if @nextFrame >= @frames.length || @nextFrame >= @imageParts.length # no new frame to render\n\n    index = @nextFrame++\n    frame = @frames[index]\n\n    # check if one of duplicates, but not the first in group\n    previousFrame = null\n    if @previousFrames.has(index - 1)\n      previousFrame = @previousFrames.get(index - 1)\n\n    if index > 0 and @groups.has(frame.data) and @groups.get(frame.data)[0] != index\n      setTimeout =>\n        @frameFinished frame, true\n      , 0\n      return\n\n    worker = @freeWorkers.shift()\n    task = @getTask frame, previousFrame\n\n    @log \"starting frame #{ task.index + 1 } of #{ @frames.length }\"\n    @activeWorkers.push worker\n    worker.postMessage task#, [task.data.buffer]\n    # Dispose unused memory.\n    @frames[index] = null\n    @previousFrames[index - 1] = null\n\n  getContextData: (ctx) ->\n    return ctx.getImageData(0, 0, @options.width, @options.height).data\n\n  getImageData: (image) ->\n    if not @_canvas?\n      @_canvas = document.createElement 'canvas'\n      @_canvas.width = @options.width\n      @_canvas.height = @options.height\n\n    ctx = @_canvas.getContext '2d'\n    ctx.setFill = @options.background\n    ctx.fillRect 0, 0, @options.width, @options.height\n    ctx.drawImage image, 0, 0\n\n    return @getContextData ctx\n\n  getFrameDataForTask: (frame) ->\n    if frame.data?\n      return frame.data\n    else if frame.context?\n      return @getContextData frame.context\n    else if frame.image?\n      return @getImageData frame.image\n    else\n      throw new Error 'Invalid frame'\n\n  getTask: (frame, previousFrame) ->\n    index = @frames.indexOf frame\n    task =\n      index: index\n      last: index is (@frames.length - 1)\n      delay: frame.delay\n      transparent: frame.transparent\n      width: @options.width\n      height: @options.height\n      quality: @options.quality\n      dither: @options.dither\n      globalPalette: @options.globalPalette\n      repeat: @options.repeat\n      canTransfer: true\n      data: @getFrameDataForTask frame\n      applyCropOptimization: @options.applyCropOptimization\n      transparencyDifferenceThreshold: @options.transparencyDifferenceThreshold\n      dispose: @options.dispose\n      applyTransparencyOptimization: @options.applyTransparencyOptimization\n\n    if previousFrame?\n      task.previousFrameData = @getFrameDataForTask previousFrame\n\n    return task\n\n  log: (msg) ->\n    console.log msg if @options.debug\n\nmodule.exports = GIF\n\n\n// WEBPACK FOOTER //\n// ./src/gif.coffee","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/events/events.js\n// module id = 1\n// module chunks = 0","### CoffeeScript version of the browser detection from MooTools ###\n\nua = navigator.userAgent.toLowerCase()\nplatform = navigator.platform.toLowerCase()\nUA = ua.match(/(opera|ie|firefox|chrome|version)[\\s\\/:]([\\w\\d\\.]+)?.*?(safari|version[\\s\\/:]([\\w\\d\\.]+)|$)/) or [null, 'unknown', 0]\nmode = UA[1] == 'ie' && document.documentMode\n\nbrowser =\n  name: if UA[1] is 'version' then UA[3] else UA[1]\n  version: mode or parseFloat(if UA[1] is 'opera' && UA[4] then UA[4] else UA[2])\n\n  platform:\n    name: if ua.match(/ip(?:ad|od|hone)/) then 'ios' else (ua.match(/(?:webos|android)/) or platform.match(/mac|win|linux/) or ['other'])[0]\n\nbrowser[browser.name] = true\nbrowser[browser.name + parseInt(browser.version, 10)] = true\nbrowser.platform[browser.platform.name] = true\n\nmodule.exports = browser\n\n\n\n// WEBPACK FOOTER //\n// ./src/browser.coffee"],"sourceRoot":""}