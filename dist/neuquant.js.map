{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///neuquant.js","webpack:///webpack/bootstrap 4bf14815c955eb24ba37?5506","webpack:///./src/NeuQuant.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","toInt","v","NeuQuant","pixels","samplefac","init","network","netindex","bias","freq","radpower","i","netsize","netbiasshift","intbias","unbiasnet","altersingle","alpha","b","g","r","initalpha","alterneigh","radius","a","lo","Math","abs","hi","min","j","k","alpharadbias","contest","n","dist","biasdist","betafreq","bestd","bestbiasd","bestpos","bestbiaspos","intbiasshift","betashift","gammashift","beta","betagamma","inxbuild","q","smallpos","smallval","previouscol","startpos","maxnetpos","inxsearch","best","learn","lengthcount","length","alphadec","samplepixels","delta","ncycles","initradius","rad","radiusbiasshift","radbias","step","minpicturebytes","prime1","prime2","prime3","prime4","pix","radiusdec","buildColormap","getColormap","map","index","l","lookupRGB","initrad","radiusbias","alphabiasshift","radbiasshift","alpharadbshift"],"mappings":"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","file":"neuquant.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"GIF\"] = factory();\n\telse\n\t\troot[\"GIF\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"GIF\"] = factory();\n\telse\n\t\troot[\"GIF\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\n\t/* NeuQuant Neural-Net Quantization Algorithm\n\t * ------------------------------------------\n\t *\n\t * Copyright (c) 1994 Anthony Dekker\n\t *\n\t * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994.\n\t * See \"Kohonen neural networks for optimal colour quantization\"\n\t * in \"Network: Computation in Neural Systems\" Vol. 5 (1994) pp 351-367.\n\t * for a discussion of the algorithm.\n\t * See also  http://members.ozemail.com.au/~dekker/NEUQUANT.HTML\n\t *\n\t * Any party obtaining a copy of these files from the author, directly or\n\t * indirectly, is granted, free of charge, a full and unrestricted irrevocable,\n\t * world-wide, paid up, royalty-free, nonexclusive right and license to deal\n\t * in this software and documentation files (the \"Software\"), including without\n\t * limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n\t * and/or sell copies of the Software, and to permit persons who receive\n\t * copies from any such party to do so, with the only requirement being\n\t * that this copyright notice remain intact.\n\t *\n\t * (JavaScript port 2012 by Johan Nordberg)\n\t *\n\t * Micro-optimization\n\t *  Roman Viskin (npm@terikon.com)\n\t */\n\t\n\tfunction toInt(v) {\n\t  return ~~v;\n\t}\n\t\n\tvar ncycles = 100; // number of learning cycles\n\tvar netsize = 256; // number of colors used\n\tvar maxnetpos = netsize - 1;\n\t\n\t// defs for freq and bias\n\tvar netbiasshift = 4; // bias for colour values\n\tvar intbiasshift = 16; // bias for fractions\n\tvar intbias = (1 << intbiasshift);\n\tvar gammashift = 10;\n\tvar gamma = (1 << gammashift);\n\tvar betashift = 10;\n\tvar beta = (intbias >> betashift); /* beta = 1/1024 */\n\tvar betagamma = (intbias << (gammashift - betashift));\n\t\n\t// defs for decreasing radius factor\n\tvar initrad = (netsize >> 3); // for 256 cols, radius starts\n\tvar radiusbiasshift = 6; // at 32.0 biased by 6 bits\n\tvar radiusbias = (1 << radiusbiasshift);\n\tvar initradius = (initrad * radiusbias); //and decreases by a\n\tvar radiusdec = 30; // factor of 1/30 each cycle\n\t\n\t// defs for decreasing alpha factor\n\tvar alphabiasshift = 10; // alpha starts at 1.0\n\tvar initalpha = (1 << alphabiasshift);\n\tvar alphadec; // biased by 10 bits\n\t\n\t/* radbias and alpharadbias used for radpower calculation */\n\tvar radbiasshift = 8;\n\tvar radbias = (1 << radbiasshift);\n\tvar alpharadbshift = (alphabiasshift + radbiasshift);\n\tvar alpharadbias = (1 << alpharadbshift);\n\t\n\t// four primes near 500 - assume no image has a length so large that it is\n\t// divisible by all four primes\n\tvar prime1 = 499;\n\tvar prime2 = 491;\n\tvar prime3 = 487;\n\tvar prime4 = 503;\n\tvar minpicturebytes = (3 * prime4);\n\t\n\t/*\n\t  Constructor: NeuQuant\n\t\n\t  Arguments:\n\t\n\t  pixels - array of pixels in RGB format\n\t  samplefac - sampling factor 1 to 30 where lower is better quality\n\t\n\t  >\n\t  > pixels = [r, g, b, r, g, b, r, g, b, ..]\n\t  >\n\t*/\n\tfunction NeuQuant(pixels, samplefac) {\n\t  var network; // int[netsize][4]\n\t  var netindex; // for network lookup - really 256\n\t\n\t  // bias and freq arrays for learning\n\t  var bias;\n\t  var freq;\n\t  var radpower;\n\t\n\t  /*\n\t    Private Method: init\n\t\n\t    sets up arrays\n\t  */\n\t  function init() {\n\t    network = [];\n\t    netindex = [];\n\t    bias = [];\n\t    freq = [];\n\t    radpower = [];\n\t\n\t    var i, v;\n\t    for (i = 0; i < netsize; i++) {\n\t      v = (i << (netbiasshift + 8)) / netsize;\n\t      network[i] = [v, v, v];\n\t      freq[i] = intbias / netsize;\n\t      bias[i] = 0;\n\t    }\n\t  }\n\t\n\t  /*\n\t    Private Method: unbiasnet\n\t\n\t    unbiases network to give byte values 0..255 and record position i to prepare for sort\n\t  */\n\t  function unbiasnet() {\n\t    for (var i = 0; i < netsize; i++) {\n\t      network[i][0] >>= netbiasshift;\n\t      network[i][1] >>= netbiasshift;\n\t      network[i][2] >>= netbiasshift;\n\t      network[i][3] = i; // record color number\n\t    }\n\t  }\n\t\n\t  /*\n\t    Private Method: altersingle\n\t\n\t    moves neuron *i* towards biased (b,g,r) by factor *alpha*\n\t  */\n\t  function altersingle(alpha, i, b, g, r) {\n\t    network[i][0] -= (alpha * (network[i][0] - b)) / initalpha;\n\t    network[i][1] -= (alpha * (network[i][1] - g)) / initalpha;\n\t    network[i][2] -= (alpha * (network[i][2] - r)) / initalpha;\n\t  }\n\t\n\t  /*\n\t    Private Method: alterneigh\n\t\n\t    moves neurons in *radius* around index *i* towards biased (b,g,r) by factor *alpha*\n\t  */\n\t  function alterneigh(radius, i, b, g, r) {\n\t    var lo = Math.abs(i - radius);\n\t    var hi = Math.min(i + radius, netsize);\n\t\n\t    var j = i + 1;\n\t    var k = i - 1;\n\t    var m = 1;\n\t\n\t    var p, a;\n\t    while ((j < hi) || (k > lo)) {\n\t      a = radpower[m++];\n\t\n\t      if (j < hi) {\n\t        p = network[j++];\n\t        p[0] -= (a * (p[0] - b)) / alpharadbias;\n\t        p[1] -= (a * (p[1] - g)) / alpharadbias;\n\t        p[2] -= (a * (p[2] - r)) / alpharadbias;\n\t      }\n\t\n\t      if (k > lo) {\n\t        p = network[k--];\n\t        p[0] -= (a * (p[0] - b)) / alpharadbias;\n\t        p[1] -= (a * (p[1] - g)) / alpharadbias;\n\t        p[2] -= (a * (p[2] - r)) / alpharadbias;\n\t      }\n\t    }\n\t  }\n\t\n\t  /*\n\t    Private Method: contest\n\t\n\t    searches for biased BGR values\n\t\n\t    should be heavily optimized\n\t  */\n\t  function contest(b, g, r) {\n\t    /*\n\t      finds closest neuron (min dist) and updates freq\n\t      finds best neuron (min dist-bias) and returns position\n\t      for frequently chosen neurons, freq[i] is high and bias[i] is negative\n\t      bias[i] = gamma * ((1 / netsize) - freq[i])\n\t    */\n\t\n\t    b = b | 0;\n\t    g = g | 0;\n\t    r = r | 0;\n\t\n\t    var bestd = ~(1 << 31);\n\t    var bestbiasd = bestd;\n\t    var bestpos = -1;\n\t    var bestbiaspos = bestpos;\n\t\n\t    var i, n, dist, biasdist, betafreq;\n\t    for (i = 0; i < netsize; i++) {\n\t      n = network[i];\n\t\n\t      dist = (Math.abs((n[0] | 0) - b) + Math.abs((n[1] | 0) - g) + Math.abs((n[2] | 0) - r)) | 0;\n\t      if (dist < bestd) {\n\t        bestd = dist;\n\t        bestpos = i;\n\t      }\n\t\n\t      biasdist = dist - ((bias[i] | 0) >> (intbiasshift - netbiasshift));\n\t      if (biasdist < bestbiasd) {\n\t        bestbiasd = biasdist;\n\t        bestbiaspos = i;\n\t      }\n\t\n\t      betafreq = (freq[i] >> betashift);\n\t      freq[i] -= betafreq;\n\t      bias[i] += (betafreq << gammashift);\n\t    }\n\t\n\t    freq[bestpos] += beta;\n\t    bias[bestpos] -= betagamma;\n\t\n\t    return bestbiaspos;\n\t  }\n\t\n\t  /*\n\t    Private Method: inxbuild\n\t\n\t    sorts network and builds netindex[0..255]\n\t  */\n\t  function inxbuild() {\n\t    var i, j, p, q, smallpos, smallval, previouscol = 0, startpos = 0;\n\t    for (i = 0; i < netsize; i++) {\n\t      p = network[i];\n\t      smallpos = i;\n\t      smallval = p[1]; // index on g\n\t      // find smallest in i..netsize-1\n\t      for (j = i + 1; j < netsize; j++) {\n\t        q = network[j];\n\t        if (q[1] < smallval) { // index on g\n\t          smallpos = j;\n\t          smallval = q[1]; // index on g\n\t        }\n\t      }\n\t      q = network[smallpos];\n\t      // swap p (i) and q (smallpos) entries\n\t      if (i != smallpos) {\n\t        j = q[0];   q[0] = p[0];   p[0] = j;\n\t        j = q[1];   q[1] = p[1];   p[1] = j;\n\t        j = q[2];   q[2] = p[2];   p[2] = j;\n\t        j = q[3];   q[3] = p[3];   p[3] = j;\n\t      }\n\t      // smallval entry is now in position i\n\t\n\t      if (smallval != previouscol) {\n\t        netindex[previouscol] = (startpos + i) >> 1;\n\t        for (j = previouscol + 1; j < smallval; j++)\n\t          netindex[j] = i;\n\t        previouscol = smallval;\n\t        startpos = i;\n\t      }\n\t    }\n\t    netindex[previouscol] = (startpos + maxnetpos) >> 1;\n\t    for (j = previouscol + 1; j < 256; j++)\n\t      netindex[j] = maxnetpos; // really 256\n\t  }\n\t\n\t  /*\n\t    Private Method: inxsearch\n\t\n\t    searches for BGR values 0..255 and returns a color index\n\t\n\t    should be heavily optimized\n\t  */\n\t  function inxsearch(b, g, r) {\n\t\n\t    b = b | 0;\n\t    g = g | 0;\n\t    r = r | 0;\n\t\n\t    var a, p, dist;\n\t\n\t    var bestd = 1000; // biggest possible dist is 256*3\n\t    var best = -1;\n\t\n\t    var i = netindex[g] | 0; // index on g\n\t    var j = i - 1; // start at netindex[g] and work outwards\n\t\n\t    while ((i < netsize) || (j >= 0)) {\n\t      if (i < netsize) {\n\t        p = network[i];\n\t        dist = (p[1] | 0) - g; // inx key\n\t        if (dist >= bestd) i = netsize; // stop iter\n\t        else {\n\t          i++;\n\t          if (dist < 0) dist = -dist;\n\t          a = (p[0] | 0) - b; if (a < 0) a = -a;\n\t          dist += a;\n\t          if (dist < bestd) {\n\t            a = (p[2] | 0) - r; if (a < 0) a = -a;\n\t            dist += a;\n\t            if (dist < bestd) {\n\t              bestd = dist;\n\t              best = p[3] | 0;\n\t            }\n\t          }\n\t        }\n\t      }\n\t      if (j >= 0) {\n\t        p = network[j];\n\t        dist = g - (p[1] | 0); // inx key - reverse dif\n\t        if (dist >= bestd) j = -1; // stop iter\n\t        else {\n\t          j--;\n\t          if (dist < 0) dist = -dist;\n\t          a = (p[0] | 0) - b; if (a < 0) a = -a;\n\t          dist += a;\n\t          if (dist < bestd) {\n\t            a = (p[2] | 0) - r; if (a < 0) a = -a;\n\t            dist += a;\n\t            if (dist < bestd) {\n\t              bestd = dist;\n\t              best = p[3] | 0;\n\t            }\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    return best;\n\t  }\n\t\n\t  /*\n\t    Private Method: learn\n\t\n\t    \"Main Learning Loop\"\n\t  */\n\t  function learn() {\n\t    var i;\n\t\n\t    var lengthcount = pixels.length;\n\t    var alphadec = toInt(30 + ((samplefac - 1) / 3));\n\t    var samplepixels = toInt(lengthcount / (3 * samplefac));\n\t    var delta = toInt(samplepixels / ncycles);\n\t    var alpha = initalpha;\n\t    var radius = initradius;\n\t\n\t    var rad = radius >> radiusbiasshift;\n\t\n\t    if (rad <= 1) rad = 0;\n\t    for (i = 0; i < rad; i++)\n\t      radpower[i] = toInt(alpha * (((rad * rad - i * i) * radbias) / (rad * rad)));\n\t\n\t    var step;\n\t    if (lengthcount < minpicturebytes) {\n\t      samplefac = 1;\n\t      step = 3;\n\t    } else if ((lengthcount % prime1) !== 0) {\n\t      step = 3 * prime1;\n\t    } else if ((lengthcount % prime2) !== 0) {\n\t      step = 3 * prime2;\n\t    } else if ((lengthcount % prime3) !== 0)  {\n\t      step = 3 * prime3;\n\t    } else {\n\t      step = 3 * prime4;\n\t    }\n\t\n\t    var b, g, r, j;\n\t    var pix = 0; // current pixel\n\t\n\t    i = 0;\n\t    while (i < samplepixels) {\n\t      b = (pixels[pix] & 0xff) << netbiasshift;\n\t      g = (pixels[pix + 1] & 0xff) << netbiasshift;\n\t      r = (pixels[pix + 2] & 0xff) << netbiasshift;\n\t\n\t      j = contest(b, g, r);\n\t\n\t      altersingle(alpha, j, b, g, r);\n\t      if (rad !== 0) alterneigh(rad, j, b, g, r); // alter neighbours\n\t\n\t      pix += step;\n\t      if (pix >= lengthcount) pix -= lengthcount;\n\t\n\t      i++;\n\t\n\t      if (delta === 0) delta = 1;\n\t      if (i % delta === 0) {\n\t        alpha -= alpha / alphadec;\n\t        radius -= radius / radiusdec;\n\t        rad = radius >> radiusbiasshift;\n\t\n\t        if (rad <= 1) rad = 0;\n\t        for (j = 0; j < rad; j++)\n\t          radpower[j] = toInt(alpha * (((rad * rad - j * j) * radbias) / (rad * rad)));\n\t      }\n\t    }\n\t  }\n\t\n\t  /*\n\t    Method: buildColormap\n\t\n\t    1. initializes network\n\t    2. trains it\n\t    3. removes misconceptions\n\t    4. builds colorindex\n\t  */\n\t  function buildColormap() {\n\t    init();\n\t    learn();\n\t    unbiasnet();\n\t    inxbuild();\n\t  }\n\t  this.buildColormap = buildColormap;\n\t\n\t  /*\n\t    Method: getColormap\n\t\n\t    builds colormap from the index\n\t\n\t    returns array in the format:\n\t\n\t    >\n\t    > [r, g, b, r, g, b, r, g, b, ..]\n\t    >\n\t  */\n\t  function getColormap() {\n\t    var map = [];\n\t    var index = [];\n\t\n\t    for (var i = 0; i < netsize; i++)\n\t      index[network[i][3]] = i;\n\t\n\t    var k = 0;\n\t    for (var l = 0; l < netsize; l++) {\n\t      var j = index[l];\n\t      map[k++] = (network[j][0]);\n\t      map[k++] = (network[j][1]);\n\t      map[k++] = (network[j][2]);\n\t    }\n\t    return map;\n\t  }\n\t  this.getColormap = getColormap;\n\t\n\t  /*\n\t    Method: lookupRGB\n\t\n\t    looks for the closest *r*, *g*, *b* color in the map and\n\t    returns its index\n\t  */\n\t  this.lookupRGB = inxsearch;\n\t}\n\t\n\tmodule.exports = NeuQuant;\n\n\n/***/ })\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// neuquant.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 4bf14815c955eb24ba37","/* NeuQuant Neural-Net Quantization Algorithm\n * ------------------------------------------\n *\n * Copyright (c) 1994 Anthony Dekker\n *\n * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994.\n * See \"Kohonen neural networks for optimal colour quantization\"\n * in \"Network: Computation in Neural Systems\" Vol. 5 (1994) pp 351-367.\n * for a discussion of the algorithm.\n * See also  http://members.ozemail.com.au/~dekker/NEUQUANT.HTML\n *\n * Any party obtaining a copy of these files from the author, directly or\n * indirectly, is granted, free of charge, a full and unrestricted irrevocable,\n * world-wide, paid up, royalty-free, nonexclusive right and license to deal\n * in this software and documentation files (the \"Software\"), including without\n * limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons who receive\n * copies from any such party to do so, with the only requirement being\n * that this copyright notice remain intact.\n *\n * (JavaScript port 2012 by Johan Nordberg)\n *\n * Micro-optimization\n *  Roman Viskin (npm@terikon.com)\n */\n\nfunction toInt(v) {\n  return ~~v;\n}\n\nvar ncycles = 100; // number of learning cycles\nvar netsize = 256; // number of colors used\nvar maxnetpos = netsize - 1;\n\n// defs for freq and bias\nvar netbiasshift = 4; // bias for colour values\nvar intbiasshift = 16; // bias for fractions\nvar intbias = (1 << intbiasshift);\nvar gammashift = 10;\nvar gamma = (1 << gammashift);\nvar betashift = 10;\nvar beta = (intbias >> betashift); /* beta = 1/1024 */\nvar betagamma = (intbias << (gammashift - betashift));\n\n// defs for decreasing radius factor\nvar initrad = (netsize >> 3); // for 256 cols, radius starts\nvar radiusbiasshift = 6; // at 32.0 biased by 6 bits\nvar radiusbias = (1 << radiusbiasshift);\nvar initradius = (initrad * radiusbias); //and decreases by a\nvar radiusdec = 30; // factor of 1/30 each cycle\n\n// defs for decreasing alpha factor\nvar alphabiasshift = 10; // alpha starts at 1.0\nvar initalpha = (1 << alphabiasshift);\nvar alphadec; // biased by 10 bits\n\n/* radbias and alpharadbias used for radpower calculation */\nvar radbiasshift = 8;\nvar radbias = (1 << radbiasshift);\nvar alpharadbshift = (alphabiasshift + radbiasshift);\nvar alpharadbias = (1 << alpharadbshift);\n\n// four primes near 500 - assume no image has a length so large that it is\n// divisible by all four primes\nvar prime1 = 499;\nvar prime2 = 491;\nvar prime3 = 487;\nvar prime4 = 503;\nvar minpicturebytes = (3 * prime4);\n\n/*\n  Constructor: NeuQuant\n\n  Arguments:\n\n  pixels - array of pixels in RGB format\n  samplefac - sampling factor 1 to 30 where lower is better quality\n\n  >\n  > pixels = [r, g, b, r, g, b, r, g, b, ..]\n  >\n*/\nfunction NeuQuant(pixels, samplefac) {\n  var network; // int[netsize][4]\n  var netindex; // for network lookup - really 256\n\n  // bias and freq arrays for learning\n  var bias;\n  var freq;\n  var radpower;\n\n  /*\n    Private Method: init\n\n    sets up arrays\n  */\n  function init() {\n    network = [];\n    netindex = [];\n    bias = [];\n    freq = [];\n    radpower = [];\n\n    var i, v;\n    for (i = 0; i < netsize; i++) {\n      v = (i << (netbiasshift + 8)) / netsize;\n      network[i] = [v, v, v];\n      freq[i] = intbias / netsize;\n      bias[i] = 0;\n    }\n  }\n\n  /*\n    Private Method: unbiasnet\n\n    unbiases network to give byte values 0..255 and record position i to prepare for sort\n  */\n  function unbiasnet() {\n    for (var i = 0; i < netsize; i++) {\n      network[i][0] >>= netbiasshift;\n      network[i][1] >>= netbiasshift;\n      network[i][2] >>= netbiasshift;\n      network[i][3] = i; // record color number\n    }\n  }\n\n  /*\n    Private Method: altersingle\n\n    moves neuron *i* towards biased (b,g,r) by factor *alpha*\n  */\n  function altersingle(alpha, i, b, g, r) {\n    network[i][0] -= (alpha * (network[i][0] - b)) / initalpha;\n    network[i][1] -= (alpha * (network[i][1] - g)) / initalpha;\n    network[i][2] -= (alpha * (network[i][2] - r)) / initalpha;\n  }\n\n  /*\n    Private Method: alterneigh\n\n    moves neurons in *radius* around index *i* towards biased (b,g,r) by factor *alpha*\n  */\n  function alterneigh(radius, i, b, g, r) {\n    var lo = Math.abs(i - radius);\n    var hi = Math.min(i + radius, netsize);\n\n    var j = i + 1;\n    var k = i - 1;\n    var m = 1;\n\n    var p, a;\n    while ((j < hi) || (k > lo)) {\n      a = radpower[m++];\n\n      if (j < hi) {\n        p = network[j++];\n        p[0] -= (a * (p[0] - b)) / alpharadbias;\n        p[1] -= (a * (p[1] - g)) / alpharadbias;\n        p[2] -= (a * (p[2] - r)) / alpharadbias;\n      }\n\n      if (k > lo) {\n        p = network[k--];\n        p[0] -= (a * (p[0] - b)) / alpharadbias;\n        p[1] -= (a * (p[1] - g)) / alpharadbias;\n        p[2] -= (a * (p[2] - r)) / alpharadbias;\n      }\n    }\n  }\n\n  /*\n    Private Method: contest\n\n    searches for biased BGR values\n\n    should be heavily optimized\n  */\n  function contest(b, g, r) {\n    /*\n      finds closest neuron (min dist) and updates freq\n      finds best neuron (min dist-bias) and returns position\n      for frequently chosen neurons, freq[i] is high and bias[i] is negative\n      bias[i] = gamma * ((1 / netsize) - freq[i])\n    */\n\n    b = b | 0;\n    g = g | 0;\n    r = r | 0;\n\n    var bestd = ~(1 << 31);\n    var bestbiasd = bestd;\n    var bestpos = -1;\n    var bestbiaspos = bestpos;\n\n    var i, n, dist, biasdist, betafreq;\n    for (i = 0; i < netsize; i++) {\n      n = network[i];\n\n      dist = (Math.abs((n[0] | 0) - b) + Math.abs((n[1] | 0) - g) + Math.abs((n[2] | 0) - r)) | 0;\n      if (dist < bestd) {\n        bestd = dist;\n        bestpos = i;\n      }\n\n      biasdist = dist - ((bias[i] | 0) >> (intbiasshift - netbiasshift));\n      if (biasdist < bestbiasd) {\n        bestbiasd = biasdist;\n        bestbiaspos = i;\n      }\n\n      betafreq = (freq[i] >> betashift);\n      freq[i] -= betafreq;\n      bias[i] += (betafreq << gammashift);\n    }\n\n    freq[bestpos] += beta;\n    bias[bestpos] -= betagamma;\n\n    return bestbiaspos;\n  }\n\n  /*\n    Private Method: inxbuild\n\n    sorts network and builds netindex[0..255]\n  */\n  function inxbuild() {\n    var i, j, p, q, smallpos, smallval, previouscol = 0, startpos = 0;\n    for (i = 0; i < netsize; i++) {\n      p = network[i];\n      smallpos = i;\n      smallval = p[1]; // index on g\n      // find smallest in i..netsize-1\n      for (j = i + 1; j < netsize; j++) {\n        q = network[j];\n        if (q[1] < smallval) { // index on g\n          smallpos = j;\n          smallval = q[1]; // index on g\n        }\n      }\n      q = network[smallpos];\n      // swap p (i) and q (smallpos) entries\n      if (i != smallpos) {\n        j = q[0];   q[0] = p[0];   p[0] = j;\n        j = q[1];   q[1] = p[1];   p[1] = j;\n        j = q[2];   q[2] = p[2];   p[2] = j;\n        j = q[3];   q[3] = p[3];   p[3] = j;\n      }\n      // smallval entry is now in position i\n\n      if (smallval != previouscol) {\n        netindex[previouscol] = (startpos + i) >> 1;\n        for (j = previouscol + 1; j < smallval; j++)\n          netindex[j] = i;\n        previouscol = smallval;\n        startpos = i;\n      }\n    }\n    netindex[previouscol] = (startpos + maxnetpos) >> 1;\n    for (j = previouscol + 1; j < 256; j++)\n      netindex[j] = maxnetpos; // really 256\n  }\n\n  /*\n    Private Method: inxsearch\n\n    searches for BGR values 0..255 and returns a color index\n\n    should be heavily optimized\n  */\n  function inxsearch(b, g, r) {\n\n    b = b | 0;\n    g = g | 0;\n    r = r | 0;\n\n    var a, p, dist;\n\n    var bestd = 1000; // biggest possible dist is 256*3\n    var best = -1;\n\n    var i = netindex[g] | 0; // index on g\n    var j = i - 1; // start at netindex[g] and work outwards\n\n    while ((i < netsize) || (j >= 0)) {\n      if (i < netsize) {\n        p = network[i];\n        dist = (p[1] | 0) - g; // inx key\n        if (dist >= bestd) i = netsize; // stop iter\n        else {\n          i++;\n          if (dist < 0) dist = -dist;\n          a = (p[0] | 0) - b; if (a < 0) a = -a;\n          dist += a;\n          if (dist < bestd) {\n            a = (p[2] | 0) - r; if (a < 0) a = -a;\n            dist += a;\n            if (dist < bestd) {\n              bestd = dist;\n              best = p[3] | 0;\n            }\n          }\n        }\n      }\n      if (j >= 0) {\n        p = network[j];\n        dist = g - (p[1] | 0); // inx key - reverse dif\n        if (dist >= bestd) j = -1; // stop iter\n        else {\n          j--;\n          if (dist < 0) dist = -dist;\n          a = (p[0] | 0) - b; if (a < 0) a = -a;\n          dist += a;\n          if (dist < bestd) {\n            a = (p[2] | 0) - r; if (a < 0) a = -a;\n            dist += a;\n            if (dist < bestd) {\n              bestd = dist;\n              best = p[3] | 0;\n            }\n          }\n        }\n      }\n    }\n\n    return best;\n  }\n\n  /*\n    Private Method: learn\n\n    \"Main Learning Loop\"\n  */\n  function learn() {\n    var i;\n\n    var lengthcount = pixels.length;\n    var alphadec = toInt(30 + ((samplefac - 1) / 3));\n    var samplepixels = toInt(lengthcount / (3 * samplefac));\n    var delta = toInt(samplepixels / ncycles);\n    var alpha = initalpha;\n    var radius = initradius;\n\n    var rad = radius >> radiusbiasshift;\n\n    if (rad <= 1) rad = 0;\n    for (i = 0; i < rad; i++)\n      radpower[i] = toInt(alpha * (((rad * rad - i * i) * radbias) / (rad * rad)));\n\n    var step;\n    if (lengthcount < minpicturebytes) {\n      samplefac = 1;\n      step = 3;\n    } else if ((lengthcount % prime1) !== 0) {\n      step = 3 * prime1;\n    } else if ((lengthcount % prime2) !== 0) {\n      step = 3 * prime2;\n    } else if ((lengthcount % prime3) !== 0)  {\n      step = 3 * prime3;\n    } else {\n      step = 3 * prime4;\n    }\n\n    var b, g, r, j;\n    var pix = 0; // current pixel\n\n    i = 0;\n    while (i < samplepixels) {\n      b = (pixels[pix] & 0xff) << netbiasshift;\n      g = (pixels[pix + 1] & 0xff) << netbiasshift;\n      r = (pixels[pix + 2] & 0xff) << netbiasshift;\n\n      j = contest(b, g, r);\n\n      altersingle(alpha, j, b, g, r);\n      if (rad !== 0) alterneigh(rad, j, b, g, r); // alter neighbours\n\n      pix += step;\n      if (pix >= lengthcount) pix -= lengthcount;\n\n      i++;\n\n      if (delta === 0) delta = 1;\n      if (i % delta === 0) {\n        alpha -= alpha / alphadec;\n        radius -= radius / radiusdec;\n        rad = radius >> radiusbiasshift;\n\n        if (rad <= 1) rad = 0;\n        for (j = 0; j < rad; j++)\n          radpower[j] = toInt(alpha * (((rad * rad - j * j) * radbias) / (rad * rad)));\n      }\n    }\n  }\n\n  /*\n    Method: buildColormap\n\n    1. initializes network\n    2. trains it\n    3. removes misconceptions\n    4. builds colorindex\n  */\n  function buildColormap() {\n    init();\n    learn();\n    unbiasnet();\n    inxbuild();\n  }\n  this.buildColormap = buildColormap;\n\n  /*\n    Method: getColormap\n\n    builds colormap from the index\n\n    returns array in the format:\n\n    >\n    > [r, g, b, r, g, b, r, g, b, ..]\n    >\n  */\n  function getColormap() {\n    var map = [];\n    var index = [];\n\n    for (var i = 0; i < netsize; i++)\n      index[network[i][3]] = i;\n\n    var k = 0;\n    for (var l = 0; l < netsize; l++) {\n      var j = index[l];\n      map[k++] = (network[j][0]);\n      map[k++] = (network[j][1]);\n      map[k++] = (network[j][2]);\n    }\n    return map;\n  }\n  this.getColormap = getColormap;\n\n  /*\n    Method: lookupRGB\n\n    looks for the closest *r*, *g*, *b* color in the map and\n    returns its index\n  */\n  this.lookupRGB = inxsearch;\n}\n\nmodule.exports = NeuQuant;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/NeuQuant.js\n// module id = 0\n// module chunks = 1"],"sourceRoot":""}